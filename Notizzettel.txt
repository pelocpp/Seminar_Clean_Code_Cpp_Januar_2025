// ==================================================

Seminar "C++ Clean Code"

Peter Loos

30+ Jahre

SW: Entwicklung // Training

C/C++, Java, C#, Mobile Progr. (Android, Java)

// ==================================================

C++ Clean Code:

2 Tools:

== Visual Studio Community 2026 

== Github

// ==================================================

Donnerstag: Weiter bei "Initialisierung von Objekten"

Inhalt:
-------

Agenda: Schwerpunkte

Clean Code C++

Flughöhe:

== Clean Coding: Details ....

== Clean Coding: Höherer Warte (Design Muster, Idiome, ...) ....

== Performanz ist ein Thema


-- Design Pattern


-- auto als Parameter // auto als Return 

-- Type Traits

-- Structured Binding // const auto& [first, relation, second]

-- Statischer vs. dynamischer Polymorphismus

   Gegenüberstellung // Beispiel: ALl-In


-- Brace Initialisierung

-- std::initializer_list

-- std::expected

-- Templates

   Folding // Variadische Templates (...) // emplace 

-- Perfektes Weiterleiten (Perfect Forwarding)

-- constexpr

-- Benutzerdefinierte Literale

-- std::ranges

-- std::string_view  // std::string

-- noexcept // Background

-- The Return of „printf”: std::print(ln) in C++ 23

-- Modul-Konzept

Verbot :)   Keine Pointer


Wenn Zeit reicht:

-- Aufrufbare Objekt   // operator()


===============================================================

Einmal virtual, immer virtual

final: Verhindert, dass in Kindklassen überschrieben wird.

Abstract Class

Ist eine unvollständige Klasse


===============================================

„High-Level”-Module   

„Low-Level”-Module


„High-Level”-Module benötigen die Dienste // API des „Low-Level”-Moduls

Wer ist der Glückliche  ?? „High-Level”-Module  - Weil in der Regel "einfacher"

Wer ist der Glückliche  ?? „Low-Level”-Module : Es wird das API geändert 

				         Schnittstellenänderung


Abstraktion mit Interfaces // Entkopplung :  Hmmm, da kommen mehr Klassen (interface) hinzu .

====================================================

Design Pattern:

Bild // UML

Text

Beispiel:  Conceptual Example // Konzeptionelles Beispiel

                      Umsetzung:  UML ==> C++ 

		  Real-World: Wo kann man das in der Praxis einsetzen.

Hmmm, hätte ich auch so gemacht ...

clientCode - Methode:

Schnittstelle der Abstraktion:  Interface

Trennung:  Client <==> Interface <==> Zielmethode / Ziellogik

====================================================

Adapter Pattern:

== JSON

== XML 

== Anderes Format

Konverter :)

Transparenter Verpacken ...

Wiederverwendbarer Verpacken ...

Flexibles Verpacken ...


====================================================

Design Pattern:

Wie genau / exakt müssen wir uns an ein Pattern halten ???

a) Details, die das Pattern nicht beschreibt:

   zB: Adaptee (fremde Klasse):  

   Als Objekt am Stack
   Via std::unique_ptr am Heap

b) Abweichungen sind legitim !!!!!!!!!

   Gründe 

c) Die Grundstruktur des Patterns sollte IMMER erkennbar sein.


============================================================

Adapter

Proxy

Gemeinsamkeiten:

== Ziel-Objekt mit Methoden

Adapter: Inkompatibilität

Proxy:   Hinzufügen von erweiterten Funktionen


Proxy für den Apdapter:  Wäre kombinierbar.

Nicht: Two - in - One.

Seperation of Concerns: Plug-and-Play

=========================================

Template Method Pattern: Schablonen-Methode

Beispiel:

Games:

Tetris:  7 Figuren

Sind ähnlich im Aufbau:

Ablauf / Bewegung:

-- Von oben nach unten
-- links oder rechts, wenn Platz ist
-- Drehen,  wenn Platz ist
-- Beendet, wenn unterhalb kein Platz ist.

Prinzipieller Ablauf ist IDENTISCH für alle Figuren.

Ablauf: EINE Methode.



============================================================

Adapter
Proxy
Template Method

Gemeinsamkeiten:

== Ziel-Objekt mit Methoden oder eine Methode gibt


Adapter:   Inkompatibilität

Proxy:     Hinzufügen von erweiterten Funktionen

Template:  

============================================================

Decorator-Namen:

Hüllen-Pattern // Wrapper-Pattern.

Decorator  ==> ausschmücken ...

Ermöglicht das Hinzufügen zusätzlicher Funktionalitäten zu Objekten zur Laufzeit.

Vererbung: Spezialisieren.

Mir gehört die Klasse möglicherweise nicht.


Decorator versus Proxy
----------------------

Gemeinsam:

Es gibt eine Ziel-Klasse mit ein oder mehreren Methoden.

Wann verwenden wir Proxy ???
Wann verwenden wir Decorator ???

Decorierer können Vorgaben zur Laufzeit entgegennehmen.

Ein Proxy ist vom "Wesen" // "Naturell" her ein STELLVERTRETER.

Bei einem Proxy will ich das Zielobjekt NICHT mehr sehen.

Ein Decorierer ist vom "Wesen" her ein Objekt,  das zusätzliche Funktionalität für 
   eine bestimmte Methode realisiert.

Ein Decorierer ist eine HÜLLE um ein Zielobjekt.


============================================================

Strategy - Pattern
==================

Back to the Roots:

STL:

std::sort (pos1, pos2, function);

comparison function object (i.e. an object that satisfies the requirements of Compare)
which returns ​true if the first argument is less than (i.e. is ordered before) the second.

The signature of the comparison function should be equivalent to the following:

bool cmp(const Type1& a, const Type2& b);  // Vergleichsfunktion

Die Vergleichsfunktion ist die STRATEGIE der std::sort Methode.

=============================================================

Modern C++:
-----------

Classic C++: interface

Modern C++:  std::function

=============================================================

Fabrik:

Erzeugt Objekt.

Hmm, dazu haben wir Klassen und deren Konstruktoren.

Toolbox von Shapes:  Circle, Rectangle, ....

Andere Herangehensweise:

a) Will Figuren aus einer  Toolbox haben

b) Kenne aber die Klassen gar nicht...

   Win32 Toolbox
   Open GL Toolbox

c) Hmm, will nur "indirekt" sagen: Gib mir einen Kreis.

d) Wie datentechnisch: interface.

Einfachste Fabrik: Simple Factory

================================================================


#if 0


//  ads
//  ads
//  ads
//  das
//  dsa
//  das

#endif


================================================================

#include "MyHeader.h"

Zum Nachdenken:

 == Lokale #include-Dateien        "MyHeader.hpp"
 
 == Drittanbieter #include-Dateien // boost // OPenGL
 
 == STL #include-Dateien           // <algorithm>  / <vector>



 Test.cpp

 #incude "Test.hpp"
 
 ========================================================

Kopierkonstruktor (Copy Constructor)	X(const X&)

  // automatisch erzeugt  =====> Byte-weise // Bit für Bit

  // Problem:   Damit würden auch Pointer kopiert werden.

Wann MUSS der implementiert werden ???

Wenn mit new im Objekt Daten allokiert werden und diese Adressen in den Instanzvariablen
liegen.





Wenn Objekte kopiert werden sollen ....








