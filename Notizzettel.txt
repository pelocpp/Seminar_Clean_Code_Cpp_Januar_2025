// ==================================================

Seminar "C++ Clean Code"

Peter Loos

peter.loos@gmx.de
-----------------

https://github.com/pelocpp

30+ Jahre

SW: Entwicklung // Training

C/C++, Java, C#, Mobile Progr. (Android, Java)

// ==================================================

C++ Clean Code:

2 Tools:

== Visual Studio Community 2026 

== Github

// ==================================================

Donnerstag: Weiter bei "Initialisierung von Objekten"

Inhalt:
-------

Agenda: Schwerpunkte

Clean Code C++

Flughöhe:

== Clean Coding: Details ....

== Clean Coding: Höherer Warte (Design Muster, Idiome, ...) ....

== Performanz ist ein Thema


-- Design Pattern


-- auto als Parameter // auto als Return 

-- Type Traits

-- Structured Binding // const auto& [first, relation, second]

-- Statischer vs. dynamischer Polymorphismus

   Gegenüberstellung // Beispiel: ALl-In


-- Brace Initialisierung

-- std::initializer_list

-- std::expected

-- Templates

   Folding // Variadische Templates (...) // emplace 

-- Perfektes Weiterleiten (Perfect Forwarding)

-- constexpr

-- Benutzerdefinierte Literale

-- std::ranges

-- std::string_view  // std::string

-- noexcept // Background

-- The Return of „printf”: std::print(ln) in C++ 23

-- Modul-Konzept

Verbot :)   Keine Pointer


Wenn Zeit reicht:

-- Aufrufbare Objekt   // operator()


===============================================================

Einmal virtual, immer virtual

final: Verhindert, dass in Kindklassen überschrieben wird.

Abstract Class

Ist eine unvollständige Klasse


===============================================

„High-Level”-Module   

„Low-Level”-Module


„High-Level”-Module benötigen die Dienste // API des „Low-Level”-Moduls

Wer ist der Glückliche  ?? „High-Level”-Module  - Weil in der Regel "einfacher"

Wer ist der Glückliche  ?? „Low-Level”-Module : Es wird das API geändert 

				         Schnittstellenänderung


Abstraktion mit Interfaces // Entkopplung :  Hmmm, da kommen mehr Klassen (interface) hinzu .

====================================================

Design Pattern:

Bild // UML

Text

Beispiel:  Conceptual Example // Konzeptionelles Beispiel

                      Umsetzung:  UML ==> C++ 

		  Real-World: Wo kann man das in der Praxis einsetzen.

Hmmm, hätte ich auch so gemacht ...

clientCode - Methode:

Schnittstelle der Abstraktion:  Interface

Trennung:  Client <==> Interface <==> Zielmethode / Ziellogik

====================================================

Adapter Pattern:

== JSON

== XML 

== Anderes Format

Konverter :)

Transparenter Verpacken ...

Wiederverwendbarer Verpacken ...

Flexibles Verpacken ...


====================================================

Design Pattern:

Wie genau / exakt müssen wir uns an ein Pattern halten ???

a) Details, die das Pattern nicht beschreibt:

   zB: Adaptee (fremde Klasse):  

   Als Objekt am Stack
   Via std::unique_ptr am Heap

b) Abweichungen sind legitim !!!!!!!!!

   Gründe 

c) Die Grundstruktur des Patterns sollte IMMER erkennbar sein.


============================================================

Adapter

Proxy

Gemeinsamkeiten:

== Ziel-Objekt mit Methoden

Adapter: Inkompatibilität

Proxy:   Hinzufügen von erweiterten Funktionen


Proxy für den Apdapter:  Wäre kombinierbar.

Nicht: Two - in - One.

Seperation of Concerns: Plug-and-Play

=========================================

Template Method Pattern: Schablonen-Methode

Beispiel:

Games:

Tetris:  7 Figuren

Sind ähnlich im Aufbau:

Ablauf / Bewegung:

-- Von oben nach unten
-- links oder rechts, wenn Platz ist
-- Drehen,  wenn Platz ist
-- Beendet, wenn unterhalb kein Platz ist.

Prinzipieller Ablauf ist IDENTISCH für alle Figuren.

Ablauf: EINE Methode.



============================================================

Adapter
Proxy
Template Method

Gemeinsamkeiten:

== Ziel-Objekt mit Methoden oder eine Methode gibt


Adapter:   Inkompatibilität

Proxy:     Hinzufügen von erweiterten Funktionen

Template:  

============================================================

Decorator-Namen:

Hüllen-Pattern // Wrapper-Pattern.

Decorator  ==> ausschmücken ...

Ermöglicht das Hinzufügen zusätzlicher Funktionalitäten zu Objekten zur Laufzeit.

Vererbung: Spezialisieren.

Mir gehört die Klasse möglicherweise nicht.


Decorator versus Proxy
----------------------

Gemeinsam:

Es gibt eine Ziel-Klasse mit ein oder mehreren Methoden.

Wann verwenden wir Proxy ???
Wann verwenden wir Decorator ???

Decorierer können Vorgaben zur Laufzeit entgegennehmen.

Ein Proxy ist vom "Wesen" // "Naturell" her ein STELLVERTRETER.

Bei einem Proxy will ich das Zielobjekt NICHT mehr sehen.

Ein Decorierer ist vom "Wesen" her ein Objekt,  das zusätzliche Funktionalität für 
   eine bestimmte Methode realisiert.

Ein Decorierer ist eine HÜLLE um ein Zielobjekt.


============================================================

Strategy - Pattern
==================

Back to the Roots:

STL:

std::sort (pos1, pos2, function);

comparison function object (i.e. an object that satisfies the requirements of Compare)
which returns ​true if the first argument is less than (i.e. is ordered before) the second.

The signature of the comparison function should be equivalent to the following:

bool cmp(const Type1& a, const Type2& b);  // Vergleichsfunktion

Die Vergleichsfunktion ist die STRATEGIE der std::sort Methode.

=============================================================

Modern C++:
-----------

Classic C++: interface

Modern C++:  std::function

=============================================================

Fabrik:

Erzeugt Objekt.

Hmm, dazu haben wir Klassen und deren Konstruktoren.

Toolbox von Shapes:  Circle, Rectangle, ....

Andere Herangehensweise:

a) Will Figuren aus einer  Toolbox haben

b) Kenne aber die Klassen gar nicht...

   Win32 Toolbox
   Open GL Toolbox

c) Hmm, will nur "indirekt" sagen: Gib mir einen Kreis.

d) Wie datentechnisch: interface.

Einfachste Fabrik: Simple Factory

================================================================


#if 0


//  ads
//  ads
//  ads
//  das
//  dsa
//  das

#endif


================================================================

#include "MyHeader.h"

Zum Nachdenken:

 == Lokale #include-Dateien        "MyHeader.hpp"
 
 == Drittanbieter #include-Dateien // boost // OPenGL
 
 == STL #include-Dateien           // <algorithm>  / <vector>



 Test.cpp

 #incude "Test.hpp"
 
 ========================================================

Kopierkonstruktor (Copy Constructor)	X(const X&)

  // automatisch erzeugt  =====> Byte-weise // Bit für Bit

  // Problem:   Damit würden auch Pointer kopiert werden.

Wann MUSS der implementiert werden ???

Wenn mit new im Objekt Daten allokiert werden und diese Adressen in den Instanzvariablen
liegen.

Wenn Objekte kopiert werden sollen ....


==================================

https://github.com/pelocpp/cpp_modern/blob/master/GeneralSnippets/BraceInitialization/BraceInitialization.md

Neue Form der Initialisierung:

Brace Initialization	Einheitliches Initialisierungs-Konzept


        int intArray7[10]{ };
00007FF6AFD7C8F9  lea         rax,[intArray7]  
00007FF6AFD7C900  mov         rdi,rax  
00007FF6AFD7C903  xor         eax,eax     // 0
00007FF6AFD7C905  mov         ecx,28h     // 28 h = 40 dez. 
00007FF6AFD7C90A  rep stos    byte ptr [rdi]  

rep Repeat Prefix: 

------------

        double d1 = ival;      // Compiles
00007FF7F4CFB710  cvtsi2sd    xmm0,dword ptr [ival]  
00007FF7F4CFB715  movsd       mmword ptr [d1],xmm0  

==================================

std::initializer_list ist kein vollwertiger STL Container

Light Weight Container:

begin()
end()
size()

std::initializer_list  ==> STACK
std::vector            ==> HEAP    ( new  , delete )

============================

elision : Auslassen , Weglassen

std::vector<int> vec( 10 );  // Size: 10 - Alle Werte: 0

vs.

std::vector<int> vec{ 10 }; // Size: 1 - Wert: 10



std::string s (10, 40);   // Len: 10, 10 Mal das Zeichen 10

std::string s { 10, 40 };  // Len: 2 -- 


==================================================

Verständnis:  "Cpp Insights"  // Andreas Fertig

=================================================

auto:

3 Möglichkeiten des Gebrauchs:

a) Vereinbarung von Variablen

b) Rückgabetyp

c) Als Parameter


// Verlust von const und & (Referenz) bei auto

=============================================

constexpr:

        constexpr Complex c3{ c1 + c2 };
00007FF735FDD5C0  movss       xmm0,dword ptr [__real@40800000 (07FF73608612Ch)]  
00007FF735FDD5C8  movss       dword ptr [c3],xmm0  
00007FF735FDD5D0  movss       xmm0,dword ptr [__real@40a00000 (07FF736086130h)]  
00007FF735FDD5D8  movss       dword ptr [rbp+8Ch],xmm0  


        /*constexpr*/ Complex c3{ c1 + c2 };
00007FF79F27EA3F  lea         r8,[c2]  
00007FF79F27EA43  lea         rdx,[c3]  
00007FF79F27EA4A  lea         rcx,[c1]  
00007FF79F27EA4E  call        ConstExprClassesAndObjects::Complex::operator+ (07FF79F274039h)  


==========================================================

Structured Binding
------------------

==========================================================

Clean Code UND Performanz:
--------------------------

Folding // C++ 17

Voraussetzung:  Variadische Templates  (...)

Folding:  "Abrollen"  // Falten

int sum = 1 + 2 + 3 + 4 + 5 + 6 + 7 + 8;

int sum = a1 + a2 + a3 + a4 + a5 + a6 + a7 + a8;

Alle Variablen a müssen als Pack vorliegen.

Optimierung für Ausdrücke mit demselben Operator.

Wie kann ich alle Variablen zu diesem Zweck "in einem Stück" in die
Hand nehmen.

====================================================

C++ hat mehrere Facetten // vereint mehrere Stile:

== OO Objekt-Orientiert

== GP Generische Programmierung 

Bjarne Stroustrup:  C++  // C with Classes

Alexander Stepanov: Generische Programmierung (Templates)

Bibliothek:  STL  Standard  Template Library

        std::vector<T>

Parameter Pack:  einpacken und auspacken.

Für das Einpacken muss eine KOMMA getrennte Liste vorliegen.

Zum Auspacken wird eine KOMMA getrennte Liste gebildet / erzeugt.


==========================================================

Wozu sind variadische Templates in der Sprache C++ enthalten:

Transport von Daten von A nach B.

zB als Parameter einer Funktion (A) hin zu einer std::initializer_list (B)

std::make_tuple

std::make_shared

std::make_unique

Threads:  std::thread  => Konstruktor

==========================================================

Beispiel zu Logging:

https://github.com/pelocpp/cpp_concurrency/blob/master/Programs/Logger/Logger.h

Was ist "Folding über einem Komma" ???????????????????  ,

Mit  dem Komma erhält man eine Sequenz:

func(), func(), func(), func(), func(); 

==========================================================

Variadische Templates:
----------------------

Perfekte Weiterleiten  // Clean & Perfect Code


===================================================

Warum geht 

        sayHello(a + b);

das so nicht: a + b ist temporär.

Grund:  Eine Referenz bezieht sich auf eine Variable / Objekt:

int n;
int& ri = n;

a + b hat keinen Namen.

===============================================

Zusammenfassung:

Guter Code
Performanter Code
Clean Code

Problem:  Es können immer wieder KOPIEN entstehen.

zB beim Aufruf von Methoden / Funktionen mit OBJEKTEN als Parameter.

Lösung:

a) Referenzen

   Hmmm: Klassische Referenz (&) - LValue-Referenz -  geht nur für Objekt mit NAMEN,
   nicht für tmp. Objekte, anonyme Objekte.

b) Neuer Referenztyp: &&  (RValue-Referenz)

   Bindet an anonyme Objekte.

c) Doch noch ein Problem: 

   Ein anonymes Objekt hat nach Funktionsaufruf wieder einen NAMEN.

     ==> Kann eigentlich nicht verschoben werden.

d) Lösung: Perfekte Weiterleiten.

   Dazu ein neuer Begriff: Universal Referenz.

   https://github.com/pelocpp/cpp_modern/blob/master/GeneralSnippets/PerfectForwarding/PerfectForwarding.md

Hier sollte man tatsächlich nach KOCHREZEPT arbeiten:

A) Parameter: T &&

    template<typename ... TArgs>
    static void logInternal(std::ostream& os, TArgs&& ...args)


B) Gebrach des Makros std::forward<>

================================================

Programmierung und Datentypen
-----------------------------

std::variant // std::visit 

==> "Type Traits"

C# / Java: Reflection API

C++: Reflection für Arme.

Nomenklatur in C++:  Metaprogramming  // Type Traits

   Programmierung mit Datentypen.

===============================================

C++ 17:

Zweite Version von if:

if compile_time (Bedingung)  <==== Übersetzer

std::is_same<ElemTypeWithoutRefAndConst, int>::value == true:

Ja, das kann der Übersetzer !!!

===============================================

std::vector:              HEAP
std::initializer_list     STACK

std::string               HEAP
std::string_view          Auf jeden Fall NICHT AM HEAP

===============================================
